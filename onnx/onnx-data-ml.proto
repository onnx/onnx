//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.
//


// Copyright (c) ONNX Project Contributors.
// Licensed under the MIT license.

syntax = "proto2";

package onnx;
import "onnx/onnx-ml.proto";

// This file contains the proto definitions for MapProto and
// SequenceProto. These protos are used to represent the data structures
// of maps and sequences in test data or can be used by ModelProto.

// Sequences and maps are made of SequenceMapElement values, which can be
// tensors, maps, or sequences.
message SequenceMapElement {
  enum DataType {
    TENSOR = 1;
    SPARSE_TENSOR = 2;
    SEQUENCE = 3;
    MAP = 4;
  }
  // The data type of the element.
  // This field MUST have a valid SequenceMapElement.DataType value
  optional int32 elem_type = 1;

  optional TensorProto tensor_value = 2;
  optional SparseTensorProto sparse_tensor_value = 3;
  optional SequenceProto sequence_value = 4;
  optional MapProto map_value = 5;
}

// Sequences
//
// Defines a dense, ordered, collection of elements that are of homogeneous types.
message SequenceProto {

  optional string name = 1;
  repeated SequenceMapElement values = 2;
}


// Key-Value pair element for MapProto. The key can be an integer or string type,
// and the value is represented by a SequenceMapElement.
message KeyValuePair {
  // The data type of the key.
  // This field MUST have a valid TensorProto.DataType value of
  // INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64, or STRING
  optional int32 key_type = 2;

  // For int32, uint8, int8, uint16, int16 keys.
  // When this field is present, the key_type field MUST be
  // INT32, INT16, INT8, UINT16, or UINT8
  optional int32 int32_data = 3;

  // For string keys.
  // Each element of string_data is a UTF-8 encoded Unicode
  // string. No trailing null, no leading BOM. The protobuf "string"
  // scalar type is not used to match ML community conventions.
  // When this field is present, the key_type field MUST be STRING
  optional bytes string_data = 4;

  // For int64 keys.
  // When this field is present, the key_type field MUST be INT64
  optional int64 int64_data = 5;

  // For uint64 and uint32 keys.
  // When this field is present, the key_type field MUST be
  // UINT32 or UINT64
  optional uint64 uint64_data = 6;

  // Serializations can either use one of the fields above, or use this
  // raw bytes field. The only exception is the string case, where one is
  // required to store the content in the repeated bytes string_data field.
  //
  // When this raw_data field is used to store the key, elements MUST
  // be stored in as fixed-width, little-endian order.
  //
  // Note: the advantage of specific field rather than the raw_data field is
  // that in some cases (e.g. int data), protobuf does a better packing via
  // variable length storage, and may lead to smaller binary footprint.
  // When this field is present, the key_type field MUST NOT be STRING or UNDEFINED
  optional bytes raw_data = 7;

  optional SequenceMapElement value = 8;
}

// Maps
//
// Specifies an associative table, defined by a key type and a value type.
message MapProto {
  optional string name = 1;

  repeated KeyValuePair pairs = 2;
}

// For using protobuf-lite
option optimize_for = LITE_RUNTIME;

