// Copyright (c) ONNX Project Contributors.
// Licensed under the MIT license.

syntax = "proto2";

package {PACKAGE_NAME};
// #if ONNX-ML
import "onnx/onnx-ml.proto";
// #else
import "onnx/onnx.proto";
// #endif

// This file contains the proto definitions for MapProto and
// SequenceProto.  These protos are used to describe the proto files for
// data structures set of operators that can be used by a ModelProto.
//
// Sequences and Maps are made of TypeProto elements, which can either be
// tensors, maps, or sequences.
//
message SequenceMapElement {
  enum DataType {
    TENSOR = 1;
    SPARSE_TENSOR = 2;
    SEQUENCE = 3;
    MAP = 4;
  }
  // The data type of the element.
  // This field MUST have a valid TensorProto.DataType value
  optional int32 elem_type = 1;

  optional TensorProto tensor_value = 2;
  optional SparseTensorProto sparse_tensor_value = 3;
  optional SequenceProto sequence_value = 4;
  optional MapProto map_value = 5;
}

// Sequences
//
// Defines a dense, ordered, collection of elements that are of homogeneous types.
message SequenceProto {

  optional string name = 1;
  repeated SequenceMapElement values = 2;
}

// Maps
//
// Specifies an associative table, defined by a key type and a value type.

// Key-Value pair element for MapProto
message KeyValuePair {
  // The data type of the key.
  // This field MUST have a valid TensorProto.DataType value of
  // INT8, INT16, INT32, INT64, UINT8, UINT16, UINT32, UINT64, or STRING
  optional int32 key_type = 2;

  // For int32, uint8, int8, uint16, int16 keys.
  // When this field is present, the key_type field MUST be
  // INT32, INT16, INT8, UINT16, or UINT8
  optional int32 int32_data = 3;

  // For string keys.
  // Each element of string_data is a UTF-8 encoded Unicode
  // string. No trailing null, no leading BOM. The protobuf "string"
  // scalar type is not used to match ML community conventions.
  // When this field is present, the key_type field MUST be STRING
  optional bytes string_data = 4;

  // For int64 keys.
  // When this field is present, the key_type field MUST be INT64
  optional int64 int64_data = 5;

  // For uint64 and uint32 keys.
  // When this field is present, the key_type field MUST be
  // UINT32 or UINT64
  optional uint64 uint64_data = 6;

  // Serializations can either use one of the fields above, or use this
  // raw bytes field. The only exception is the string case, where one is
  // required to store the content in the repeated bytes string_key field.
  //
  // When this raw_key field is used to store the key, elements MUST
  // be stored in as fixed-width, little-endian order.
  //
  // Note: the advantage of specific field rather than the raw_key field is
  // that in some cases (e.g. int data), protobuf does a better packing via
  // variable length storage, and may lead to smaller binary footprint.
  // When this field is present, the key_type field MUST NOT be STRING or UNDEFINED
  optional bytes raw_data = 7;

  optional SequenceMapElement value = 8;
}

message MapProto {
  optional string name = 1;

  repeated KeyValuePair pairs = 2;
}
