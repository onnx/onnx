## Operator Schemas
#Table of Contents 
*This file is automatically generated from the
            [def files](/onnx/defs) via [this script](/onnx/defs/gen_doc.py).
            Do not modify directly and instead edit operator definitions.*
|Operator |Input |Output |Type Constraint | Version |
|-|-|-|-|-|-|
|<a href="#Abs">Abs</a>|Input tensor|Output tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|6|
|<a href="#Acos">Acos</a>|Input tensor|The arccosine of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Acosh">Acosh</a>|Input tensor|The hyperbolic arccosine values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#Add">Add</a>|First operand.<br>Second operand.|Result, has same element type as two inputs|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|7|
|<a href="#And">And</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(bool)Constrains input to boolean tensor.<br>tensor(bool)Constrains output to boolean tensor.|7|
|<a href="#ArgMax">ArgMax</a>|An input tensor.|Reduced output tensor with integer data type.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|1|
|<a href="#ArgMin">ArgMin</a>|An input tensor.|Reduced output tensor with integer data type.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|1|
|<a href="#Asin">Asin</a>|Input tensor|The arcsine of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Asinh">Asinh</a>|Input tensor|The hyperbolic arcsine values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#Atan">Atan</a>|Input tensor|The arctangent of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Atanh">Atanh</a>|Input tensor|The hyperbolic arctangent values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#AveragePool">AveragePool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].|Output data tensor from average or max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Floor value of the dimension is used|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|10|
|<a href="#BatchNormalization">BatchNormalization</a>|Input data tensor from the previous operator; dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size, C is the number of channels. Statistics are computed for every channel of C over N and D1 to Dn dimensions. For image data, input dimensions become (N x C x H x W). The op also accepts single dimension input of size N in which case C is assumed to be 1<br>Scale tensor of shape (C).<br>Bias tensor of shape (C).<br>running (training) or estimated (testing) mean tensor of shape (C).<br>running (training) or estimated (testing) variance tensor of shape (C). (1 - 5)|The output tensor of the same shape as X<br>The running mean after the BatchNormalization operator.<br>The running variance after the BatchNormalization operator.<br>Saved mean used during training to speed up gradient computation.<br>Saved variance used during training to speed up gradient computation.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#Cast">Cast</a>|Input tensor to be cast.|Output tensor with the same shape as input with type specified by the 'to' argument|tensor(float16), tensor(float), tensor(double), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(bool), tensor(string)Constrain input types. Casting from complex is not supported.<br>tensor(float16), tensor(float), tensor(double), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(bool), tensor(string)Constrain output types. Casting to complex is not supported.|9|
|<a href="#Ceil">Ceil</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Clip">Clip</a>|Input tensor whose elements to be clipped|Output tensor with clipped input elements|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Compress">Compress</a>|Tensor of rank r >= 1.<br>Rank 1 tensor of booleans to indicate which slices or data elements to be selected. Its length can be less than the input length alone the axis or the flattened input size if axis is not specified. In such cases data slices or elements exceeding the condition length are discarded.|Tensor of rank r if axis is specified. Otherwise output is a Tensor of rank 1.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.<br>tensor(bool)Constrains to boolean tensors.|9|
|<a href="#Concat">Concat</a>|(1 - &#8734;) List of tensors for concatenation|Concatenated tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain output types to any tensor type.|4|
|<a href="#Constant">Constant</a>||Output tensor containing the same value of the provided tensor.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|9|
|<a href="#ConstantOfShape">ConstantOfShape</a>|1D tensor. The shape of the expected output tensor. If empty tensor is given, the output would be a scalar.|Output tensor of shape specified by 'input'.If attribute 'value' is specified, the value and datatype of the output tensor is taken from 'value'.If attribute 'value' is not specified, the value in the output defaults to 0, and the datatype defaults to float32.|tensor(int64)Constrain input types.<br>tensor(float16), tensor(float), tensor(double), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(bool)Constrain output types to be numerics.|9|
|<a href="#Conv">Conv</a>|(2 - 3) Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn). Optionally, if dimension denotation is in effect, the operation expects input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].<br>The weight tensor that will be used in the convolutions; has size (M x C/group x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the kernel shape will be (M x C/group x k1 x k2 x ... x kn), where (k1 x k2 x ... kn) is the dimension of the kernel. Optionally, if dimension denotation is in effect, the operation expects the weight tensor to arrive with the dimension denotation of [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...]. X.shape[1] == (W.shape[1] * group) == C (assuming zero based indices for the shape array). Or in other words FILTER_IN_CHANNEL should be equal to DATA_CHANNEL. <br>Optional 1D bias to be added to the convolution, has size of M.|Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#ConvInteger">ConvInteger</a>|(2 - 4) Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn). Optionally, if dimension denotation is in effect, the operation expects input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].<br>The weight tensor that will be used in the convolutions; has size (M x C/group x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the kernel shape will be (M x C/group x k1 x k2 x ... x kn), where (k1 x k2 x ... kn) is the dimension of the kernel. Optionally, if dimension denotation is in effect, the operation expects the weight tensor to arrive with the dimension denotation of [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...]. X.shape[1] == (W.shape[1] * group) == C (assuming zero based indices for the shape array). Or in other words FILTER_IN_CHANNEL should be equal to DATA_CHANNEL. <br>Zero point tensor for input 'x'. It's optional and default value is 0. It's a scalar, which means a per-tensor/layer quantization.<br>Scale tensor for input 'w'. It's optional and default value is 0.  It could be a scalar or a 1-D tensor, which means a per-tensor/layer or per output channel quantization. If it's a 1-D tensor, its number of elements should be equal to the number of output channels (M)|Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.|tensor(int8), tensor(uint8)Constrain input x and its zero point data type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain input w and its zero point data type to 8-bit integer tensor.<br>tensor(int32)Constrain output y data type to 32-bit integer tensor.|10|
|<a href="#ConvTranspose">ConvTranspose</a>|(2 - 3) Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn)<br>The weight tensor that will be used in the convolutions; has size (C x M/group x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the weight shape will be (C x M/group x k1 x k2 x ... x kn), where (k1 x k2 x ... x kn) is the dimension of the kernel. The number of channels in the output should be equal to W.shape[1] * group (assuming zero based indices of the shape array)<br>Optional 1D bias to be added to the convolution, has size of M.|Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, pad lengths and group count. The number of channels in the output should be equal to W.shape[1] * group (assuming zero based indices of the shape array)|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Cos">Cos</a>|Input tensor|The cosine of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Cosh">Cosh</a>|Input tensor|The hyperbolic cosine values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#DepthToSpace">DepthToSpace</a>|Input tensor of [N,C,H,W], where N is the batch axis, C is the channel or depth, H is the height and W is the width.|Output tensor of [N, C/(blocksize * blocksize), H * blocksize, W * blocksize].|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#DequantizeLinear">DequantizeLinear</a>|(2 - 3) N-D quantized input tensor to be de-quantized.<br>Scale for input 'x'. It's a scalar, which means a per-tensor/layer quantization.<br>Zero point for input 'x'. It's a scalar, which means a per-tensor/layer quantization. It's optional. 0 is the default value when it's not specified.|N-D full precision output tensor. It has same shape as input 'x'.|tensor(int8), tensor(uint8), tensor(int32)Constrain 'x_zero_point' and 'x' to 8-bit/32-bit integer tensor.|10|
|<a href="#Div">Div</a>|First operand.<br>Second operand.|Result, has same element type as two inputs|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|7|
|<a href="#Dropout">Dropout</a>|The input data as Tensor. (1 - 2)|The output.<br>The output mask.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(bool)Constrain output mask types to boolean tensors.|10|
|<a href="#Elu">Elu</a>|1D input tensor|1D input tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Equal">Equal</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(bool), tensor(int32), tensor(int64)Constrains input to integral tensors.<br>tensor(bool)Constrains output to boolean tensor.|7|
|<a href="#Erf">Erf</a>|Input tensor|The error function of the input tensor computed element-wise. It has the same shape and type of the input.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|9|
|<a href="#Exp">Exp</a>|Input tensor|The exponential of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Expand">Expand</a>|Input tensor<br>A 1-D tensor indicates the shape you want to expand to, following the broadcast rule|Output tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensors.|8|
|<a href="#EyeLike">EyeLike</a>|2D input tensor to copy shape, and optionally, type information from.|Output tensor, same shape as input tensor T1.|tensor(float16), tensor(float), tensor(double), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(bool)Constrain input types. Strings and complex are not supported.<br>tensor(float16), tensor(float), tensor(double), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(bool)Constrain output types. Strings and complex are not supported.|9|
|<a href="#Flatten">Flatten</a>|A tensor of rank >= axis.|A 2D tensor with the contents of the input tensor, with input dimensions up to axis flattened to the outer dimension of the output and remaining input dimensions flattened into the inner dimension of the output.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output to all tensor types.|9|
|<a href="#Floor">Floor</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#GRU">GRU</a>|(3 - 6) The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.<br>The weight tensor for the gates. Concatenation of `W[zrh]` and `WB[zrh]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 3*hidden_size, input_size]`.<br>The recurrence weight tensor. Concatenation of `R[zrh]` and `RB[zrh]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 3*hidden_size, hidden_size]`.<br>The bias tensor for the gates. Concatenation of `[Wb[zrh], Rb[zrh]]` and `[WBb[zrh], RBb[zrh]]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 6*hidden_size]`. Optional: If not specified - assumed to be 0<br>Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.<br>Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`. (0 - 2)|A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. <br>The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int32)Constrain seq_lens to integer tensor.|7|
|<a href="#Gather">Gather</a>|Tensor of rank r >= 1.<br>Tensor of int32/int64 indices, of any rank q.|Tensor of rank q + (r - 1).|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to any tensor type.<br>tensor(int32), tensor(int64)Constrain indices to integer types|1|
|<a href="#Gemm">Gemm</a>|Input tensor A. The shape of A should be (M, K) if transA is 0, or (K, M) if transA is non-zero.<br>Input tensor B. The shape of B should be (K, N) if transB is 0, or (N, K) if transB is non-zero.<br>Input tensor C. The shape of C should be unidirectional broadcastable to (M, N).|Output tensor of shape (M, N).|tensor(float16), tensor(float), tensor(double), tensor(uint32), tensor(uint64), tensor(int32), tensor(int64)Constrain input and output types to float/int tensors.|9|
|<a href="#GlobalAveragePool">GlobalAveragePool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.|Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#GlobalLpPool">GlobalLpPool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.|Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|2|
|<a href="#GlobalMaxPool">GlobalMaxPool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.|Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Greater">Greater</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrains input types to all numeric tensors.<br>tensor(bool)Constrains output to boolean tensor.|9|
|<a href="#HardSigmoid">HardSigmoid</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Hardmax">Hardmax</a>|The input tensor that's coerced into a 2D matrix of size (NxD) as described above.|The output values with the same shape as input tensor (the original size without coercion).|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Identity">Identity</a>|Input tensor|Tensor to copy input into.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#If">If</a>|Condition for the if (1 - &#8734;)|Values that are live-out to the enclosing scope. The return values in the `then_branch` and `else_branch` must be of the same shape and same data type.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)All Tensor types<br>tensor(bool)Only bool|1|
|<a href="#InstanceNormalization">InstanceNormalization</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.<br>The input 1-dimensional scale tensor of size C.<br>The input 1-dimensional bias tensor of size C.|The output tensor of the same shape as input.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#IsInf">IsInf</a>|input|output|tensor(float), tensor(double)Constrain input types to float tensors.<br>tensor(bool)Constrain output types to boolean tensors.|10|
|<a href="#IsNaN">IsNaN</a>|input|output|tensor(float16), tensor(float), tensor(double)Constrain input types to float tensors.<br>tensor(bool)Constrain output types to boolean tensors.|9|
|<a href="#LRN">LRN</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].|Output tensor, which has the shape and type as input tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output  types to float tensors.|1|
|<a href="#LSTM">LSTM</a>|(3 - 8) The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.<br>The weight tensor for the gates. Concatenation of `W[iofc]` and `WB[iofc]` (if bidirectional) along dimension 0. The tensor has shape `[num_directions, 4*hidden_size, input_size]`.<br>The recurrence weight tensor. Concatenation of `R[iofc]` and `RB[iofc]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 4*hidden_size, hidden_size]`.<br>The bias tensor for input gate. Concatenation of `[Wb[iofc], Rb[iofc]]`, and `[WBb[iofc], RBb[iofc]]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 8*hidden_size]`. Optional: If not specified - assumed to be 0.<br>Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.<br>Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.<br>Optional initial value of the cell. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.<br>The weight tensor for peepholes. Concatenation of `P[iof]` and `PB[iof]` (if bidirectional) along dimension 0. It has shape `[num_directions, 3*hidde_size]`. Optional: If not specified - assumed to be 0. (0 - 3)|A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. <br>The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.<br>The last output value of the cell. It has shape `[num_directions, batch_size, hidden_size]`.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int32)Constrain seq_lens to integer tensor.|7|
|<a href="#LeakyRelu">LeakyRelu</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Less">Less</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrains input types to all numeric tensors.<br>tensor(bool)Constrains output to boolean tensor.|9|
|<a href="#Log">Log</a>|Input tensor|The natural log of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#LogSoftmax">LogSoftmax</a>|The input tensor that's coerced into a 2D matrix of size (NxD) as described above.|The output values with the same shape as input tensor (the original size without coercion).|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Loop">Loop</a>|(3 - &#8734;) A maximum trip-count for the loop specified at runtime. Optional. Pass empty string to skip.<br>A boolean termination condition. Optional. Pass empty string to skip.<br>The initial values of any loop-carried dependencies (values that change across loop iterations) (1 - &#8734;)|Final N loop carried dependency values then K scan_outputs|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)All Tensor types<br>tensor(int64)tensor of int64, which should be a scalar.<br>tensor(bool)tensor of bool, which should be a scalar.|1|
|<a href="#LpNormalization">LpNormalization</a>|Input matrix|Matrix after normalization|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#LpPool">LpPool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.|Output data tensor from Lp pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|2|
|<a href="#MatMul">MatMul</a>|N-dimensional matrix A<br>N-dimensional matrix B|Matrix multiply results from A * B|tensor(float16), tensor(float), tensor(double), tensor(uint32), tensor(uint64), tensor(int32), tensor(int64)Constrain input and output types to float/int tensors.|9|
|<a href="#MatMulInteger">MatMulInteger</a>|(2 - 4) N-dimensional matrix A<br>N-dimensional matrix B<br>Zero point tensor for input 'A'. It's optional and default value is 0. It could be a scalar or a 1-D tensor, which means a per-tensor or per-row quantization. If it's a 1-D tensor, its number of elements should be equal to the number of rows of input 'A'.<br>Scale tensor for input 'B'. It's optional and default value is 0.  It could be a scalar or a 1-D tensor, which means a per-tensor or per-column quantization. If it's a 1-D tensor, its number of elements should be equal to the number of columns of input 'B'.|Matrix multiply results from A * B|tensor(int8), tensor(uint8)Constrain input A data type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain input B data type to 8-bit integer tensor.<br>tensor(int32)Constrain output Y data type as 32-bit integer tensor.|10|
|<a href="#Max">Max</a>|(1 - &#8734;) List of tensors for max.|Output tensor.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|8|
|<a href="#MaxPool">MaxPool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...]. (1 - 2)|Output data tensor from average or max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Floor value of the dimension is used<br>Indices tensor from max pooling across the input tensor. The dimensions of indices are the same as output tensor. The values in indices of are the indices of the selected values during pooling. The indices are computed as flatten 1-D tensor, and the indices do not consider padding. So the values in indices are in [0, N x C x D1 x ... x Dn).|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int64)Constrain index tensor to int64|10|
|<a href="#MaxRoiPool">MaxRoiPool</a>|Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data.<br>RoIs (Regions of Interest) to pool over. Should be a 2-D tensor of shape (num_rois, 5) given as [[batch_id, x1, y1, x2, y2], ...].|RoI pooled output 4-D tensor of shape (num_rois, channels, pooled_shape[0], pooled_shape[1]).|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#MaxUnpool">MaxUnpool</a>|(2 - 3) Input data tensor that has to be unpooled. This tensor is typically the first output of the MaxPool op.Dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non-image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].<br>Input data tensor containing the indices corresponding to elements in the first input tensor X.This tensor is typically the second output of the MaxPool op.Dimensions must be the same as input tensor X. The indices are linear, i.e. computed considering the tensor as flattened 1-D tensor, assuming row-major storage. Also, the linear indices should not consider padding. So the values in indices are in the range [0, N x C x D1 x ... x Dn).<br>The shape of the output can be explicitly set which will cause pads values to be auto generated. If 'output_shape' is specified, 'pads' values are ignored.|Output data tensor that contains the result of the unpooling.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int64)Constrain index tensor to int64|9|
|<a href="#Mean">Mean</a>|(1 - &#8734;) List of tensors for mean.|Output tensor.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|8|
|<a href="#MeanVarianceNormalization">MeanVarianceNormalization</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|9|
|<a href="#Min">Min</a>|(1 - &#8734;) List of tensors for min.|Output tensor.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|8|
|<a href="#Mod">Mod</a>|Dividend tensor<br>Divisor tensor|Remainder tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|10|
|<a href="#Mul">Mul</a>|First operand.<br>Second operand.|Result, has same element type as two inputs|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|7|
|<a href="#Multinomial">Multinomial</a>|Input tensor with shape [batch_size, class_size], where class_size is the number of all possible outcomes. Each value along the axis zero represents the unnormalized log-probability of each corresponding outcome in a batch.|Output tensor with shape [batch_size, sample_size], where sample_size is the number of times to sample. Each value along the axis zero represents the outcome of the corresponding sample in a batch.|tensor(float16), tensor(float), tensor(double)Constrain input types to float tensors.<br>tensor(int32), tensor(int64)Constrain output types to integral tensors.|7|
|<a href="#Neg">Neg</a>|Input tensor|Output tensor|tensor(float), tensor(int32), tensor(int8), tensor(int16), tensor(int64), tensor(float16), tensor(double)Constrain input and output types to signed numeric tensors.|6|
|<a href="#NonMaxSuppression">NonMaxSuppression</a>|(2 - 5) An input tensor with shape [num_batches, spatial_dimension, 4]. The single box data format is indicated by center_point_box.<br>An input tensor with shape [num_batches, num_classes, spatial_dimension]<br>Integer representing the maximum number of boxes to be selected per batch per class. It is a scalar.<br>Float representing the threshold for deciding whether boxes overlap too much with respect to IOU. It is scalar. Value range [0, 1].<br>Float representing the threshold for deciding when to remove boxes based on score. It is a scalar|selected indices from the boxes tensor. [num_selected_indices, 3], the selected index format is [batch_index, class_index, box_index].||10|
|<a href="#NonZero">NonZero</a>|input|output (always 2D tensor)|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain to all tensor types.|9|
|<a href="#Not">Not</a>|Input tensor|Output tensor|tensor(bool)Constrains input/output to boolean tensors.|1|
|<a href="#OneHot">OneHot</a>|Input tensor containing indices. The values must be non-negative integers. Any entries in the 'indices' input tensor with values outside the range [0, depth) will result in one-hot representation with all 'off_value' values in the output tensor.In case 'indices' is of non-integer type, the values will be casted to int64 before use.<br>Scalar specifying the number of classes in one-hot tensor. This is also the size of the one-hot dimension (specified by 'axis' attribute) added on in the output tensor and the values in the 'indices' input tensor are expected to be in the range [0, depth). TheIn case 'depth' is of non-integer type, it will be casted to int64 before use.<br>Rank 1 tensor containing exactly two elements, in the format [off_value, on_value], where 'on_value' is the value used for filling locations specified in 'indices' input tensor, and 'off_value' is the value used for filling locations other than those specified in 'indices' input tensor. |Tensor of rank one greater than input tensor 'indices', i.e. rank(output) = rank(indices) + 1. The data type for the elements of the output tensor is the same as the type of input 'values' is used.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrains input to only numeric types.<br>tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrains input to only numeric types.<br>tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain to any tensor type.|9|
|<a href="#Or">Or</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(bool)Constrains input to boolean tensor.<br>tensor(bool)Constrains output to boolean tensor.|7|
|<a href="#PRelu">PRelu</a>|Input tensor<br>Slope tensor. The shape of slope can be smaller then first input X; if so, its shape must be unidirectional broadcastable to X|Output tensor (same size as X)|tensor(float16), tensor(float), tensor(double), tensor(uint32), tensor(uint64), tensor(int32), tensor(int64)Constrain input and output types to float/int tensors.|9|
|<a href="#Pad">Pad</a>|Input tensor.|Tensor after padding.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|2|
|<a href="#Pow">Pow</a>|First operand, base of the exponent.<br>Second operand, power of the exponent.|Output tensor (same size as X)|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#QLinearConv">QLinearConv</a>|(8 - 9) Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn). Optionally, if dimension denotation is in effect, the operation expects input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].<br>Scale tensor for input 'x'. It's a scalar, which means a per-tensor/layer quantization.<br>Zero point tensor for input 'x'. It's a scalar, which means a per-tensor/layer quantization.<br>The weight tensor that will be used in the convolutions; has size (M x C/group x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the kernel shape will be (M x C/group x k1 x k2 x ... x kn), where (k1 x k2 x ... kn) is the dimension of the kernel. Optionally, if dimension denotation is in effect, the operation expects the weight tensor to arrive with the dimension denotation of [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...]. X.shape[1] == (W.shape[1] * group) == C (assuming zero based indices for the shape array). Or in other words FILTER_IN_CHANNEL should be equal to DATA_CHANNEL. <br>Scale tensor for input 'w'. It could be a scalar or a 1-D tensor, which means a per-tensor/layer or per output channel quantization. If it's a 1-D tensor, its number of elements should be equal to the number of output channels (M).<br>Scale tensor for input 'w'. It could be a scalar or a 1-D tensor, which means a per-tensor/layer or per output channel quantization. If it's a 1-D tensor, its number of elements should be equal to the number of output channels (M).<br>Scale tensor for output 'y'. It's a scalar, which means a per-tensor/layer quantization.<br>Scale tensor for output 'y'. It's a scalar, which means a per-tensor/layer quantization.<br>Optional 1D bias to be added to the convolution, has size of M.|Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.|tensor(int8), tensor(uint8)Constrain input type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain filter type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain output type to 8-bit integer tensor.<br>tensor(int32)Constrain bias type to 32-bit integer tensor.|10|
|<a href="#QLinearMatMul">QLinearMatMul</a>|N-dimensional quantized matrix a<br>scale of quantized input a<br>zero point of quantized input a<br>N-dimensional quantized matrix b<br>scale of quantized input b<br>zero point of quantized input b<br>scale of quantized output y<br>zero point of quantized output y|Quantized matrix multiply results from a * b|tensor(int8), tensor(uint8)Constrain input a and its zero point data type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain input b and its zero point data type to 8-bit integer tensor.<br>tensor(int8), tensor(uint8)Constrain output y and its zero point data type to 8-bit integer tensor.|10|
|<a href="#QuantizeLinear">QuantizeLinear</a>|(2 - 3) N-D full precision Input tensor to be quantized.<br>Scale for doing quantization to get 'y'. It's a scalar, which means a per-tensor/layer quantization.<br>Zero point for doing quantization to get 'y'. It's a scalar, which means a per-tensor/layer quantization. Default value is 0 if it's not specified.|N-D quantized output tensor. It has same shape as input 'x'.|tensor(float), tensor(int32)Constrain 'x' to float or int32 tensor.<br>tensor(int8), tensor(uint8)Constrain 'y_zero_point' and 'y' to 8-bit integer tensor.|10|
|<a href="#RNN">RNN</a>|(3 - 6) The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.<br>The weight tensor for input gate. Concatenation of `Wi` and `WBi` (if bidirectional). The tensor has shape `[num_directions, hidden_size, input_size]`.<br>The recurrence weight tensor. Concatenation of `Ri` and `RBi` (if bidirectional). The tensor has shape `[num_directions, hidden_size, hidden_size]`.<br>The bias tensor for input gate. Concatenation of `[Wbi, Rbi]` and `[WBbi, RBbi]` (if bidirectional). The tensor has shape `[num_directions, 2*hidden_size]`. Optional: If not specified - assumed to be 0.<br>Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.<br>Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`. (0 - 2)|A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. <br>The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int32)Constrain seq_lens to integer tensor.|7|
|<a href="#RandomNormal">RandomNormal</a>||Output tensor of random values drawn from normal distribution|tensor(float16), tensor(float), tensor(double)Constrain output types to float tensors.|1|
|<a href="#RandomNormalLike">RandomNormalLike</a>|Input tensor to copy shape and optionally type information from.|Output tensor of random values drawn from normal distribution|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain to any tensor type. If the dtype attribute is not provided this must be a valid output type.<br>tensor(float16), tensor(float), tensor(double)Constrain output types to float tensors.|1|
|<a href="#RandomUniform">RandomUniform</a>||Output tensor of random values drawn from uniform distribution|tensor(float16), tensor(float), tensor(double)Constrain output types to float tensors.|1|
|<a href="#RandomUniformLike">RandomUniformLike</a>|Input tensor to copy shape and optionally type information from.|Output tensor of random values drawn from uniform distribution|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain to any tensor type. If the dtype attribute is not provided this must be a valid output type.<br>tensor(float16), tensor(float), tensor(double)Constrain output types to float tensors.|1|
|<a href="#Reciprocal">Reciprocal</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#ReduceL1">ReduceL1</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceL2">ReduceL2</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceLogSum">ReduceLogSum</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceLogSumExp">ReduceLogSumExp</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceMax">ReduceMax</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceMean">ReduceMean</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceMin">ReduceMin</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceProd">ReduceProd</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceSum">ReduceSum</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#ReduceSumSquare">ReduceSumSquare</a>|An input tensor.|Reduced output tensor.|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|1|
|<a href="#Relu">Relu</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Reshape">Reshape</a>|An input tensor.<br>Specified shape for output.|Reshaped data.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|5|
|<a href="#Resize">Resize</a>|N-D tensor<br>The scale array along each dimension. It takes value greater than 0. If it's less than 1, it's sampling down, otherwise, it's upsampling. The number of elements of 'scales' should be the same as the rank of input 'X'.|N-D tensor after resizing|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input 'X' and output 'Y' to all tensor types.|10|
|<a href="#ReverseSequence">ReverseSequence</a>|Tensor of rank r >= 2.<br>Tensor specifying lengths of the sequences in a batch. It has shape `[batch_size]`.|Tensor with same shape of input.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Input and output types can be of any tensor type.|10|
|<a href="#RoiAlign">RoiAlign</a>|Input data tensor from the previous operator; 4-D feature map of shape (N, C, H, W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data.<br>RoIs (Regions of Interest) to pool over; rois is 2-D input of shape (num_rois, 4) given as [[x1, y1, x2, y2], ...]. The RoIs' coordinates are in the coordinate system of the input image. Each coordinate set has a 1:1 correspondence with the 'batch_indices' input.<br>1-D tensor of shape (num_rois,) with each element denoting the index of the corresponding image in the batch.|RoI pooled output, 4-D tensor of shape (num_rois, C, output_height, output_width). The r-th batch element Y[r-1] is a pooled feature map corresponding to the r-th RoI X[r-1].|tensor(float16), tensor(float), tensor(double)Constrain types to float tensors.<br>tensor(int64)Constrain types to int tensors.|10|
|<a href="#Scan">Scan</a>|(1 - &#8734;) Initial values of the loop's N state variables followed by M scan_inputs (1 - &#8734;)|Final values of the loop's N state variables followed by K scan_outputs|tensor(int64)Int64 tensor<br>tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)All Tensor types|9|
|<a href="#Scatter">Scatter</a>|Tensor of rank r >= 1.<br>Tensor of int32/int64 indices, of r >= 1 (same rank as input).<br>Tensor of rank r >=1 (same rank and shape as indices)|Tensor of rank r >= 1 (same rank as input).|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Input and output types can be of any tensor type.<br>tensor(int32), tensor(int64)Constrain indices to integer types|9|
|<a href="#Selu">Selu</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Shape">Shape</a>|An input tensor.|Shape of the input tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Input tensor can be of arbitrary type.<br>tensor(int64)Constrain output to int64 tensor.|1|
|<a href="#Shrink">Shrink</a>|The input data as Tensor.|The output.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrains input to only numeric types.|9|
|<a href="#Sigmoid">Sigmoid</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Sign">Sign</a>|Input tensor|The sign of the input tensor computed element-wise. It has the same shape and type of the input.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to all numeric tensors.|9|
|<a href="#Sin">Sin</a>|Input tensor|The sine of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Sinh">Sinh</a>|Input tensor|The hyperbolic sine values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|9|
|<a href="#Size">Size</a>|An input tensor.|Total number of elements of the input tensor|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Input tensor can be of arbitrary type.<br>tensor(int64)Constrain output to int64 tensor, which should be a scalar though.|1|
|<a href="#Slice">Slice</a>|(3 - 5) Tensor of data to extract slices from.<br>1-D tensor of starting indices of corresponding axis in `axes`<br>1-D tensor of ending indices (exclusive) of corresponding axis in `axes`<br>1-D tensor of axes that `starts` and `ends` apply to.<br>1-D tensor of slice step of corresponding axis in `axes`. Default to 1. |Sliced data tensor.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.<br>tensor(int32), tensor(int64)Constrain indices to integer types|10|
|<a href="#Softmax">Softmax</a>|The input tensor that's coerced into a 2D matrix of size (NxD) as described above.|The output values with the same shape as input tensor (the original size without coercion).|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Softplus">Softplus</a>|1D input tensor|1D input tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#Softsign">Softsign</a>|Input tensor|The softsign (x/(1+|x|)) values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|1|
|<a href="#SpaceToDepth">SpaceToDepth</a>|Input tensor of [N,C,H,W], where N is the batch axis, C is the channel or depth, H is the height and W is the width.|Output tensor of [N, C * blocksize * blocksize, H/blocksize, W/blocksize].|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#Split">Split</a>|The tensor to split (1 - &#8734;)|One or more outputs forming list of tensors after splitting|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|2|
|<a href="#Sqrt">Sqrt</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#Squeeze">Squeeze</a>|Tensors with at least max(dims) dimensions.|Reshaped tensor with same data as input.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#StringNormalizer">StringNormalizer</a>|UTF-8 strings to normalize|UTF-8 Normalized strings||10|
|<a href="#Sub">Sub</a>|First operand.<br>Second operand.|Result, has same element type as two inputs|tensor(uint32), tensor(uint64), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double)Constrain input and output types to high-precision numeric tensors.|7|
|<a href="#Sum">Sum</a>|(1 - &#8734;) List of tensors for sum.|Output tensor.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|8|
|<a href="#Tan">Tan</a>|Input tensor|The tangent of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|7|
|<a href="#Tanh">Tanh</a>|Input tensor|The hyperbolic tangent values of the input tensor computed element-wise|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|6|
|<a href="#TfIdfVectorizer">TfIdfVectorizer</a>|Input for n-gram extraction|Ngram results|tensor(string), tensor(int32), tensor(int64)Input is ether string UTF-8 or int32/int64<br>tensor(float)1-D tensor of floats|9|
|<a href="#ThresholdedRelu">ThresholdedRelu</a>|Input tensor|Output tensor|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.|10|
|<a href="#Tile">Tile</a>|Input tensor of any shape.<br>1D int64 tensor of the same length as input's dimension number, includes numbers of repeated copies along input's dimensions.|Output tensor of the same dimension and type as tensor input. output_dim[i] = input_dim[i] * repeats[i]|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.<br>tensor(int64)Constrain repeat's type to int64 tensors.|6|
|<a href="#TopK">TopK</a>|Tensor of shape [a_1, a_2, ..., a_n, r]<br>A 1-D tensor containing a single positive value corresponding to the number of top elements to retrieve|Tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n] containing top K values from the input tensor<br>Tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n] containing the corresponding input tensor indices for the top K values.|tensor(float16), tensor(float), tensor(double)Constrain input and output types to float tensors.<br>tensor(int64)Constrain index tensor to int64|10|
|<a href="#Transpose">Transpose</a>|An input tensor.|Transposed output.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#Unsqueeze">Unsqueeze</a>|Original tensor|Reshaped tensor with same data as input.|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|1|
|<a href="#Upsample">Upsample</a>|N-D tensor<br>The scale array along each dimension. It takes value greater than or equal to 1. The number of elements of 'scales' should be the same as the rank of input 'X'.|N-D tensor after resizing|tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input 'X' and output 'Y' to all tensor types.|10|
|<a href="#Where">Where</a>|When True (nonzero), yield X, otherwise yield Y<br>values selected at indices where condition is True<br>values selected at indices where condition is False|Tensor of shape equal to the broadcasted shape of condition, X, and Y.|tensor(bool)Constrain to boolean tensors.<br>tensor(uint8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(int8), tensor(int16), tensor(int32), tensor(int64), tensor(float16), tensor(float), tensor(double), tensor(string), tensor(bool), tensor(complex64), tensor(complex128)Constrain input and output types to all tensor types.|9|
|<a href="#Xor">Xor</a>|First input operand for the logical operator.<br>Second input operand for the logical operator.|Result tensor.|tensor(bool)Constrains input to boolean tensor.<br>tensor(bool)Constrains output to boolean tensor.|7|
