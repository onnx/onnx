// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onnx.proto

package onnx

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
type Version int32

const (
	// proto3 requires the first enum value to be zero.
	// We add this just to appease the compiler.
	Version__START_VERSION Version = 0
	// The version field is always serialized and we will use it to store the
	// version that the  graph is generated from. This helps us set up version
	// control.
	// For the IR, we are using simple numbers starting with with 0x00000001,
	// which was the version we published on Oct 10, 2017.
	Version_IR_VERSION_2017_10_10 Version = 1
	// IR_VERSION 2 published on Oct 30, 2017
	// - Added type discriminator to AttributeProto to support proto3 users
	Version_IR_VERSION_2017_10_30 Version = 2
	// IR VERSION 3 published on Nov 3, 2017
	// - For operator versioning:
	//    - Added new message OperatorSetIdProto
	//    - Added opset_import in ModelProto
	// - For vendor extensions, added domain in NodeProto
	Version_IR_VERSION Version = 3
)

var Version_name = map[int32]string{
	0: "_START_VERSION",
	1: "IR_VERSION_2017_10_10",
	2: "IR_VERSION_2017_10_30",
	3: "IR_VERSION",
}
var Version_value = map[string]int32{
	"_START_VERSION":        0,
	"IR_VERSION_2017_10_10": 1,
	"IR_VERSION_2017_10_30": 2,
	"IR_VERSION":            3,
}

func (x Version) Enum() *Version {
	p := new(Version)
	*p = x
	return p
}
func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}
func (x *Version) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Version_value, data, "Version")
	if err != nil {
		return err
	}
	*x = Version(value)
	return nil
}
func (Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{0}
}

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
type AttributeProto_AttributeType int32

const (
	AttributeProto_UNDEFINED AttributeProto_AttributeType = 0
	AttributeProto_FLOAT     AttributeProto_AttributeType = 1
	AttributeProto_INT       AttributeProto_AttributeType = 2
	AttributeProto_STRING    AttributeProto_AttributeType = 3
	AttributeProto_TENSOR    AttributeProto_AttributeType = 4
	AttributeProto_GRAPH     AttributeProto_AttributeType = 5
	AttributeProto_FLOATS    AttributeProto_AttributeType = 6
	AttributeProto_INTS      AttributeProto_AttributeType = 7
	AttributeProto_STRINGS   AttributeProto_AttributeType = 8
	AttributeProto_TENSORS   AttributeProto_AttributeType = 9
	AttributeProto_GRAPHS    AttributeProto_AttributeType = 10
)

var AttributeProto_AttributeType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT",
	3:  "STRING",
	4:  "TENSOR",
	5:  "GRAPH",
	6:  "FLOATS",
	7:  "INTS",
	8:  "STRINGS",
	9:  "TENSORS",
	10: "GRAPHS",
}
var AttributeProto_AttributeType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT":       2,
	"STRING":    3,
	"TENSOR":    4,
	"GRAPH":     5,
	"FLOATS":    6,
	"INTS":      7,
	"STRINGS":   8,
	"TENSORS":   9,
	"GRAPHS":    10,
}

func (x AttributeProto_AttributeType) Enum() *AttributeProto_AttributeType {
	p := new(AttributeProto_AttributeType)
	*p = x
	return p
}
func (x AttributeProto_AttributeType) String() string {
	return proto.EnumName(AttributeProto_AttributeType_name, int32(x))
}
func (x *AttributeProto_AttributeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AttributeProto_AttributeType_value, data, "AttributeProto_AttributeType")
	if err != nil {
		return err
	}
	*x = AttributeProto_AttributeType(value)
	return nil
}
func (AttributeProto_AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{0, 0}
}

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types.
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_UINT8  TensorProto_DataType = 2
	TensorProto_INT8   TensorProto_DataType = 3
	TensorProto_UINT16 TensorProto_DataType = 4
	TensorProto_INT16  TensorProto_DataType = 5
	TensorProto_INT32  TensorProto_DataType = 6
	TensorProto_INT64  TensorProto_DataType = 7
	TensorProto_STRING TensorProto_DataType = 8
	TensorProto_BOOL   TensorProto_DataType = 9
	// Advanced types
	TensorProto_FLOAT16    TensorProto_DataType = 10
	TensorProto_DOUBLE     TensorProto_DataType = 11
	TensorProto_UINT32     TensorProto_DataType = 12
	TensorProto_UINT64     TensorProto_DataType = 13
	TensorProto_COMPLEX64  TensorProto_DataType = 14
	TensorProto_COMPLEX128 TensorProto_DataType = 15
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "UINT8",
	3:  "INT8",
	4:  "UINT16",
	5:  "INT16",
	6:  "INT32",
	7:  "INT64",
	8:  "STRING",
	9:  "BOOL",
	10: "FLOAT16",
	11: "DOUBLE",
	12: "UINT32",
	13: "UINT64",
	14: "COMPLEX64",
	15: "COMPLEX128",
}
var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED":  0,
	"FLOAT":      1,
	"UINT8":      2,
	"INT8":       3,
	"UINT16":     4,
	"INT16":      5,
	"INT32":      6,
	"INT64":      7,
	"STRING":     8,
	"BOOL":       9,
	"FLOAT16":    10,
	"DOUBLE":     11,
	"UINT32":     12,
	"UINT64":     13,
	"COMPLEX64":  14,
	"COMPLEX128": 15,
}

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}
func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}
func (x *TensorProto_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_DataType_value, data, "TensorProto_DataType")
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(value)
	return nil
}
func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{6, 0}
}

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or repeated float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
type AttributeProto struct {
	// The name field MUST be present for this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
	// In this case, this AttributeProto does not contain data, and it's a reference of attribute
	// in parent scope.
	// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
	RefAttrName *string `protobuf:"bytes,21,opt,name=ref_attr_name,json=refAttrName" json:"ref_attr_name,omitempty"`
	// A human-readable documentation for this attribute. Markdown is allowed.
	DocString *string `protobuf:"bytes,13,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The type field MUST be present for this version of the IR.
	// For 0.0.1 versions of the IR, this field was not defined, and
	// implementations needed to use has_field hueristics to determine
	// which value field was in use.  For IR_VERSION 0.0.2 or later, this
	// field MUST be set and match the f|i|s|t|... field in use.  This
	// change was made to accomodate proto3 implementations.
	Type *AttributeProto_AttributeType `protobuf:"varint,20,opt,name=type,enum=onnx.AttributeProto_AttributeType" json:"type,omitempty"`
	// Exactly ONE of the following fields must be present for this version of the IR
	F                    *float32       `protobuf:"fixed32,2,opt,name=f" json:"f,omitempty"`
	I                    *int64         `protobuf:"varint,3,opt,name=i" json:"i,omitempty"`
	S                    []byte         `protobuf:"bytes,4,opt,name=s" json:"s,omitempty"`
	T                    *TensorProto   `protobuf:"bytes,5,opt,name=t" json:"t,omitempty"`
	G                    *GraphProto    `protobuf:"bytes,6,opt,name=g" json:"g,omitempty"`
	Floats               []float32      `protobuf:"fixed32,7,rep,name=floats" json:"floats,omitempty"`
	Ints                 []int64        `protobuf:"varint,8,rep,name=ints" json:"ints,omitempty"`
	Strings              [][]byte       `protobuf:"bytes,9,rep,name=strings" json:"strings,omitempty"`
	Tensors              []*TensorProto `protobuf:"bytes,10,rep,name=tensors" json:"tensors,omitempty"`
	Graphs               []*GraphProto  `protobuf:"bytes,11,rep,name=graphs" json:"graphs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttributeProto) Reset()         { *m = AttributeProto{} }
func (m *AttributeProto) String() string { return proto.CompactTextString(m) }
func (*AttributeProto) ProtoMessage()    {}
func (*AttributeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{0}
}
func (m *AttributeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttributeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeProto.Merge(dst, src)
}
func (m *AttributeProto) XXX_Size() int {
	return m.Size()
}
func (m *AttributeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeProto.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeProto proto.InternalMessageInfo

func (m *AttributeProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AttributeProto) GetRefAttrName() string {
	if m != nil && m.RefAttrName != nil {
		return *m.RefAttrName
	}
	return ""
}

func (m *AttributeProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *AttributeProto) GetType() AttributeProto_AttributeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AttributeProto_UNDEFINED
}

func (m *AttributeProto) GetF() float32 {
	if m != nil && m.F != nil {
		return *m.F
	}
	return 0
}

func (m *AttributeProto) GetI() int64 {
	if m != nil && m.I != nil {
		return *m.I
	}
	return 0
}

func (m *AttributeProto) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *AttributeProto) GetT() *TensorProto {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *AttributeProto) GetG() *GraphProto {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *AttributeProto) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *AttributeProto) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *AttributeProto) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *AttributeProto) GetTensors() []*TensorProto {
	if m != nil {
		return m.Tensors
	}
	return nil
}

func (m *AttributeProto) GetGraphs() []*GraphProto {
	if m != nil {
		return m.Graphs
	}
	return nil
}

// Defines information on value, including the name, the type, and
// the shape of the value.
type ValueInfoProto struct {
	// This field MUST be present in this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// This field MUST be present in this version of the IR.
	Type *TypeProto `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// A human-readable documentation for this value. Markdown is allowed.
	DocString            *string  `protobuf:"bytes,3,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValueInfoProto) Reset()         { *m = ValueInfoProto{} }
func (m *ValueInfoProto) String() string { return proto.CompactTextString(m) }
func (*ValueInfoProto) ProtoMessage()    {}
func (*ValueInfoProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{1}
}
func (m *ValueInfoProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueInfoProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueInfoProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValueInfoProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueInfoProto.Merge(dst, src)
}
func (m *ValueInfoProto) XXX_Size() int {
	return m.Size()
}
func (m *ValueInfoProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueInfoProto.DiscardUnknown(m)
}

var xxx_messageInfo_ValueInfoProto proto.InternalMessageInfo

func (m *ValueInfoProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ValueInfoProto) GetType() *TypeProto {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ValueInfoProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter
// tensor and a bias tensor, and produces the convolved output.
type NodeProto struct {
	Input  []string `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"`
	// An optional identifier for this node in a graph.
	// This field MAY be absent in ths version of the IR.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The symbolic identifier of the Operator to execute.
	OpType *string `protobuf:"bytes,4,opt,name=op_type,json=opType" json:"op_type,omitempty"`
	// The domain of the OperatorSet that specifies the operator named by op_type.
	Domain *string `protobuf:"bytes,7,opt,name=domain" json:"domain,omitempty"`
	// Additional named attributes.
	Attribute []*AttributeProto `protobuf:"bytes,5,rep,name=attribute" json:"attribute,omitempty"`
	// A human-readable documentation for this node. Markdown is allowed.
	DocString            *string  `protobuf:"bytes,6,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeProto) Reset()         { *m = NodeProto{} }
func (m *NodeProto) String() string { return proto.CompactTextString(m) }
func (*NodeProto) ProtoMessage()    {}
func (*NodeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{2}
}
func (m *NodeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProto.Merge(dst, src)
}
func (m *NodeProto) XXX_Size() int {
	return m.Size()
}
func (m *NodeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProto.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProto proto.InternalMessageInfo

func (m *NodeProto) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NodeProto) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *NodeProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NodeProto) GetOpType() string {
	if m != nil && m.OpType != nil {
		return *m.OpType
	}
	return ""
}

func (m *NodeProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *NodeProto) GetAttribute() []*AttributeProto {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *NodeProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto.
type ModelProto struct {
	// The version of the IR this model targets. See Version enum above.
	// This field MUST be present.
	IrVersion *int64 `protobuf:"varint,1,opt,name=ir_version,json=irVersion" json:"ir_version,omitempty"`
	// The OperatorSets this model relies on.
	// All ModelProtos MUST have at least one entry that
	// specifies which version of the ONNX OperatorSet is
	// being imported.
	//
	// All nodes in the ModelProto's graph will bind against the operator
	// with the same-domain/same-op_type operator with the HIGHEST version
	// in the referenced operator sets.
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,8,rep,name=opset_import,json=opsetImport" json:"opset_import,omitempty"`
	// The name of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerName *string `protobuf:"bytes,2,opt,name=producer_name,json=producerName" json:"producer_name,omitempty"`
	// The version of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerVersion *string `protobuf:"bytes,3,opt,name=producer_version,json=producerVersion" json:"producer_version,omitempty"`
	// Domain name of the model.
	// We use reverse domain names as name space indicators. For example:
	// `com.facebook.fair` or `com.microsoft.cognitiveservices`
	//
	// Together with `model_version` and GraphProto.name, this forms the unique identity of
	// the graph.
	Domain *string `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	// The version of the graph encoded. See Version enum below.
	ModelVersion *int64 `protobuf:"varint,5,opt,name=model_version,json=modelVersion" json:"model_version,omitempty"`
	// A human-readable documentation for this model. Markdown is allowed.
	DocString *string `protobuf:"bytes,6,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The parameterized graph that is evaluated to execute the model.
	Graph *GraphProto `protobuf:"bytes,7,opt,name=graph" json:"graph,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps        []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ModelProto) Reset()         { *m = ModelProto{} }
func (m *ModelProto) String() string { return proto.CompactTextString(m) }
func (*ModelProto) ProtoMessage()    {}
func (*ModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{3}
}
func (m *ModelProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto.Merge(dst, src)
}
func (m *ModelProto) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto proto.InternalMessageInfo

func (m *ModelProto) GetIrVersion() int64 {
	if m != nil && m.IrVersion != nil {
		return *m.IrVersion
	}
	return 0
}

func (m *ModelProto) GetOpsetImport() []*OperatorSetIdProto {
	if m != nil {
		return m.OpsetImport
	}
	return nil
}

func (m *ModelProto) GetProducerName() string {
	if m != nil && m.ProducerName != nil {
		return *m.ProducerName
	}
	return ""
}

func (m *ModelProto) GetProducerVersion() string {
	if m != nil && m.ProducerVersion != nil {
		return *m.ProducerVersion
	}
	return ""
}

func (m *ModelProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *ModelProto) GetModelVersion() int64 {
	if m != nil && m.ModelVersion != nil {
		return *m.ModelVersion
	}
	return 0
}

func (m *ModelProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *ModelProto) GetGraph() *GraphProto {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ModelProto) GetMetadataProps() []*StringStringEntryProto {
	if m != nil {
		return m.MetadataProps
	}
	return nil
}

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type StringStringEntryProto struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringStringEntryProto) Reset()         { *m = StringStringEntryProto{} }
func (m *StringStringEntryProto) String() string { return proto.CompactTextString(m) }
func (*StringStringEntryProto) ProtoMessage()    {}
func (*StringStringEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{4}
}
func (m *StringStringEntryProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringStringEntryProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringStringEntryProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StringStringEntryProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringStringEntryProto.Merge(dst, src)
}
func (m *StringStringEntryProto) XXX_Size() int {
	return m.Size()
}
func (m *StringStringEntryProto) XXX_DiscardUnknown() {
	xxx_messageInfo_StringStringEntryProto.DiscardUnknown(m)
}

var xxx_messageInfo_StringStringEntryProto proto.InternalMessageInfo

func (m *StringStringEntryProto) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringStringEntryProto) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
type GraphProto struct {
	// The nodes in the graph, sorted topologically.
	Node []*NodeProto `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
	// The name of the graph.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// A list of named tensor values, used to specify constant inputs of the graph.
	// Each TensorProto entry must have a distinct name (within the list) that
	// also appears in the input list.
	Initializer []*TensorProto `protobuf:"bytes,5,rep,name=initializer" json:"initializer,omitempty"`
	// A human-readable documentation for this graph. Markdown is allowed.
	DocString *string `protobuf:"bytes,10,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The inputs and outputs of the graph.
	Input  []*ValueInfoProto `protobuf:"bytes,11,rep,name=input" json:"input,omitempty"`
	Output []*ValueInfoProto `protobuf:"bytes,12,rep,name=output" json:"output,omitempty"`
	// Information for the values in the graph. The ValueInfoProto.name's
	// must be distinct. It is optional for a value to appear in value_info list.
	ValueInfo            []*ValueInfoProto `protobuf:"bytes,13,rep,name=value_info,json=valueInfo" json:"value_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GraphProto) Reset()         { *m = GraphProto{} }
func (m *GraphProto) String() string { return proto.CompactTextString(m) }
func (*GraphProto) ProtoMessage()    {}
func (*GraphProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{5}
}
func (m *GraphProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GraphProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphProto.Merge(dst, src)
}
func (m *GraphProto) XXX_Size() int {
	return m.Size()
}
func (m *GraphProto) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphProto.DiscardUnknown(m)
}

var xxx_messageInfo_GraphProto proto.InternalMessageInfo

func (m *GraphProto) GetNode() []*NodeProto {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GraphProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GraphProto) GetInitializer() []*TensorProto {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *GraphProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *GraphProto) GetInput() []*ValueInfoProto {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *GraphProto) GetOutput() []*ValueInfoProto {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *GraphProto) GetValueInfo() []*ValueInfoProto {
	if m != nil {
		return m.ValueInfo
	}
	return nil
}

// Tensors
//
// A serialized tensor value.
type TensorProto struct {
	// The shape of the tensor.
	Dims []int64 `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	// The data type of the tensor.
	DataType *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,enum=onnx.TensorProto_DataType" json:"data_type,omitempty"`
	Segment  *TensorProto_Segment  `protobuf:"bytes,3,opt,name=segment" json:"segment,omitempty"`
	// For float and complex64 values
	// Complex64 tensors are encoded as a single array of floats,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
	FloatData []float32 `protobuf:"fixed32,4,rep,packed,name=float_data,json=floatData" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16 values
	// float16 values must be bit-wise converted to an uint16_t prior
	// to writing to the buffer.
	// When this field is present, the data_type field MUST be
	// INT32, INT16, INT8, UINT16, INT8, BOOL, or FLOAT16
	Int32Data []int32 `protobuf:"varint,5,rep,packed,name=int32_data,json=int32Data" json:"int32_data,omitempty"`
	// For strings.
	// Each element of string_data is a UTF-8 encoded Unicode
	// string. No trailing null, no leading BOM. The protobuf "string"
	// scalar type is not used to match ML community conventions.
	// When this field is present, the data_type field MUST be STRING
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData" json:"string_data,omitempty"`
	// For int64.
	// When this field is present, the data_type field MUST be INT64
	Int64Data []int64 `protobuf:"varint,7,rep,packed,name=int64_data,json=int64Data" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name *string `protobuf:"bytes,8,opt,name=name" json:"name,omitempty"`
	// A human-readable documentation for this tensor. Markdown is allowed.
	DocString *string `protobuf:"bytes,12,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// Serializations can either use one of the fields above, or use this
	// raw bytes field. The only exception is the string case, where one is
	// required to store the content in the repeated bytes string_data field.
	//
	// When this raw_data field is used to store tensor value, elements MUST
	// be stored in as fixed-width, little-endian order.
	// Floating-point data types MUST be stored in IEEE 754 format.
	// Complex64 elements must be written as two consecutive FLOAT values, real component first.
	// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
	// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
	//
	// Note: the advantage of specific field rather than the raw_data field is
	// that in some cases (e.g. int data), protobuf does a better packing via
	// variable length storage, and may lead to smaller binary footprint.
	// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
	RawData []byte `protobuf:"bytes,9,opt,name=raw_data,json=rawData" json:"raw_data,omitempty"`
	// For double
	// Complex64 tensors are encoded as a single array of doubles,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
	DoubleData []float64 `protobuf:"fixed64,10,rep,packed,name=double_data,json=doubleData" json:"double_data,omitempty"`
	// For uint64 and uint32 values
	// When this field is present, the data_type field MUST be
	// UINT32 or UINT64
	Uint64Data           []uint64 `protobuf:"varint,11,rep,packed,name=uint64_data,json=uint64Data" json:"uint64_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorProto) Reset()         { *m = TensorProto{} }
func (m *TensorProto) String() string { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()    {}
func (*TensorProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{6}
}
func (m *TensorProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TensorProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto.Merge(dst, src)
}
func (m *TensorProto) XXX_Size() int {
	return m.Size()
}
func (m *TensorProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto proto.InternalMessageInfo

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return TensorProto_UNDEFINED
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TensorProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *TensorProto) GetRawData() []byte {
	if m != nil {
		return m.RawData
	}
	return nil
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetUint64Data() []uint64 {
	if m != nil {
		return m.Uint64Data
	}
	return nil
}

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
type TensorProto_Segment struct {
	Begin                *int64   `protobuf:"varint,1,opt,name=begin" json:"begin,omitempty"`
	End                  *int64   `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorProto_Segment) Reset()         { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()    {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{6, 0}
}
func (m *TensorProto_Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorProto_Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorProto_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TensorProto_Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto_Segment.Merge(dst, src)
}
func (m *TensorProto_Segment) XXX_Size() int {
	return m.Size()
}
func (m *TensorProto_Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto_Segment proto.InternalMessageInfo

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil && m.Begin != nil {
		return *m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
type TensorShapeProto struct {
	Dim                  []*TensorShapeProto_Dimension `protobuf:"bytes,1,rep,name=dim" json:"dim,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *TensorShapeProto) Reset()         { *m = TensorShapeProto{} }
func (m *TensorShapeProto) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto) ProtoMessage()    {}
func (*TensorShapeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{7}
}
func (m *TensorShapeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorShapeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorShapeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TensorShapeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto.Merge(dst, src)
}
func (m *TensorShapeProto) XXX_Size() int {
	return m.Size()
}
func (m *TensorShapeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto proto.InternalMessageInfo

func (m *TensorShapeProto) GetDim() []*TensorShapeProto_Dimension {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorShapeProto_Dimension struct {
	// Types that are valid to be assigned to Value:
	//	*TensorShapeProto_Dimension_DimValue
	//	*TensorShapeProto_Dimension_DimParam
	Value isTensorShapeProto_Dimension_Value `protobuf_oneof:"value"`
	// Standard denotation can optionally be used to denote tensor
	// dimensions with standard semantic descriptions to ensure
	// that operations are applied to the correct axis of a tensor.
	// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
	// for pre-defined dimension denotations.
	Denotation           *string  `protobuf:"bytes,3,opt,name=denotation" json:"denotation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorShapeProto_Dimension) Reset()         { *m = TensorShapeProto_Dimension{} }
func (m *TensorShapeProto_Dimension) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto_Dimension) ProtoMessage()    {}
func (*TensorShapeProto_Dimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{7, 0}
}
func (m *TensorShapeProto_Dimension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorShapeProto_Dimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorShapeProto_Dimension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TensorShapeProto_Dimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto_Dimension.Merge(dst, src)
}
func (m *TensorShapeProto_Dimension) XXX_Size() int {
	return m.Size()
}
func (m *TensorShapeProto_Dimension) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto_Dimension.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto_Dimension proto.InternalMessageInfo

type isTensorShapeProto_Dimension_Value interface {
	isTensorShapeProto_Dimension_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorShapeProto_Dimension_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,json=dimValue,oneof"`
}
type TensorShapeProto_Dimension_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,json=dimParam,oneof"`
}

func (*TensorShapeProto_Dimension_DimValue) isTensorShapeProto_Dimension_Value() {}
func (*TensorShapeProto_Dimension_DimParam) isTensorShapeProto_Dimension_Value() {}

func (m *TensorShapeProto_Dimension) GetValue() isTensorShapeProto_Dimension_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TensorShapeProto_Dimension) GetDimValue() int64 {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimValue); ok {
		return x.DimValue
	}
	return 0
}

func (m *TensorShapeProto_Dimension) GetDimParam() string {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimParam); ok {
		return x.DimParam
	}
	return ""
}

func (m *TensorShapeProto_Dimension) GetDenotation() string {
	if m != nil && m.Denotation != nil {
		return *m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TensorShapeProto_Dimension) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TensorShapeProto_Dimension_OneofMarshaler, _TensorShapeProto_Dimension_OneofUnmarshaler, _TensorShapeProto_Dimension_OneofSizer, []interface{}{
		(*TensorShapeProto_Dimension_DimValue)(nil),
		(*TensorShapeProto_Dimension_DimParam)(nil),
	}
}

func _TensorShapeProto_Dimension_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DimParam)
	case nil:
	default:
		return fmt.Errorf("TensorShapeProto_Dimension.Value has unexpected type %T", x)
	}
	return nil
}

func _TensorShapeProto_Dimension_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TensorShapeProto_Dimension)
	switch tag {
	case 1: // value.dim_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &TensorShapeProto_Dimension_DimValue{int64(x)}
		return true, err
	case 2: // value.dim_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &TensorShapeProto_Dimension_DimParam{x}
		return true, err
	default:
		return false, nil
	}
}

func _TensorShapeProto_Dimension_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.DimParam)))
		n += len(x.DimParam)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Types
//
// The standard ONNX data types.
type TypeProto struct {
	// Types that are valid to be assigned to Value:
	//	*TypeProto_TensorType
	Value isTypeProto_Value `protobuf_oneof:"value"`
	// An optional denotation can be used to denote the whole
	// type with a standard semantic description as to what is
	// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
	// for pre-defined type denotations.
	Denotation           *string  `protobuf:"bytes,6,opt,name=denotation" json:"denotation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypeProto) Reset()         { *m = TypeProto{} }
func (m *TypeProto) String() string { return proto.CompactTextString(m) }
func (*TypeProto) ProtoMessage()    {}
func (*TypeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{8}
}
func (m *TypeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TypeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto.Merge(dst, src)
}
func (m *TypeProto) XXX_Size() int {
	return m.Size()
}
func (m *TypeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto proto.InternalMessageInfo

type isTypeProto_Value interface {
	isTypeProto_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TypeProto_TensorType struct {
	TensorType *TypeProto_Tensor `protobuf:"bytes,1,opt,name=tensor_type,json=tensorType,oneof"`
}

func (*TypeProto_TensorType) isTypeProto_Value() {}

func (m *TypeProto) GetValue() isTypeProto_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TypeProto) GetTensorType() *TypeProto_Tensor {
	if x, ok := m.GetValue().(*TypeProto_TensorType); ok {
		return x.TensorType
	}
	return nil
}

func (m *TypeProto) GetDenotation() string {
	if m != nil && m.Denotation != nil {
		return *m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TypeProto) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TypeProto_OneofMarshaler, _TypeProto_OneofUnmarshaler, _TypeProto_OneofSizer, []interface{}{
		(*TypeProto_TensorType)(nil),
	}
}

func _TypeProto_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TensorType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TypeProto.Value has unexpected type %T", x)
	}
	return nil
}

func _TypeProto_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TypeProto)
	switch tag {
	case 1: // value.tensor_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeProto_Tensor)
		err := b.DecodeMessage(msg)
		m.Value = &TypeProto_TensorType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TypeProto_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		s := proto.Size(x.TensorType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TypeProto_Tensor struct {
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST be present for this version of the IR.
	ElemType             *TensorProto_DataType `protobuf:"varint,1,opt,name=elem_type,json=elemType,enum=onnx.TensorProto_DataType" json:"elem_type,omitempty"`
	Shape                *TensorShapeProto     `protobuf:"bytes,2,opt,name=shape" json:"shape,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TypeProto_Tensor) Reset()         { *m = TypeProto_Tensor{} }
func (m *TypeProto_Tensor) String() string { return proto.CompactTextString(m) }
func (*TypeProto_Tensor) ProtoMessage()    {}
func (*TypeProto_Tensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{8, 0}
}
func (m *TypeProto_Tensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeProto_Tensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeProto_Tensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TypeProto_Tensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto_Tensor.Merge(dst, src)
}
func (m *TypeProto_Tensor) XXX_Size() int {
	return m.Size()
}
func (m *TypeProto_Tensor) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto_Tensor.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto_Tensor proto.InternalMessageInfo

func (m *TypeProto_Tensor) GetElemType() TensorProto_DataType {
	if m != nil && m.ElemType != nil {
		return *m.ElemType
	}
	return TensorProto_UNDEFINED
}

func (m *TypeProto_Tensor) GetShape() *TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
type OperatorSetIdProto struct {
	// The domain of the operator set being identified.
	// The empty string ("") or absence of this field implies the operator
	// set that is defined as part of the ONNX specification.
	// This field MUST be present in this version of the IR when referring to any other operator set.
	Domain *string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The version of the operator set being identified.
	// This field MUST be present in this version of the IR.
	Version              *int64   `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperatorSetIdProto) Reset()         { *m = OperatorSetIdProto{} }
func (m *OperatorSetIdProto) String() string { return proto.CompactTextString(m) }
func (*OperatorSetIdProto) ProtoMessage()    {}
func (*OperatorSetIdProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_onnx_66ef03ffacf11547, []int{9}
}
func (m *OperatorSetIdProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorSetIdProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorSetIdProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OperatorSetIdProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorSetIdProto.Merge(dst, src)
}
func (m *OperatorSetIdProto) XXX_Size() int {
	return m.Size()
}
func (m *OperatorSetIdProto) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorSetIdProto.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorSetIdProto proto.InternalMessageInfo

func (m *OperatorSetIdProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *OperatorSetIdProto) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func init() {
	proto.RegisterType((*AttributeProto)(nil), "onnx.AttributeProto")
	proto.RegisterType((*ValueInfoProto)(nil), "onnx.ValueInfoProto")
	proto.RegisterType((*NodeProto)(nil), "onnx.NodeProto")
	proto.RegisterType((*ModelProto)(nil), "onnx.ModelProto")
	proto.RegisterType((*StringStringEntryProto)(nil), "onnx.StringStringEntryProto")
	proto.RegisterType((*GraphProto)(nil), "onnx.GraphProto")
	proto.RegisterType((*TensorProto)(nil), "onnx.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "onnx.TensorProto.Segment")
	proto.RegisterType((*TensorShapeProto)(nil), "onnx.TensorShapeProto")
	proto.RegisterType((*TensorShapeProto_Dimension)(nil), "onnx.TensorShapeProto.Dimension")
	proto.RegisterType((*TypeProto)(nil), "onnx.TypeProto")
	proto.RegisterType((*TypeProto_Tensor)(nil), "onnx.TypeProto.Tensor")
	proto.RegisterType((*OperatorSetIdProto)(nil), "onnx.OperatorSetIdProto")
	proto.RegisterEnum("onnx.Version", Version_name, Version_value)
	proto.RegisterEnum("onnx.AttributeProto_AttributeType", AttributeProto_AttributeType_name, AttributeProto_AttributeType_value)
	proto.RegisterEnum("onnx.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
}
func (m *AttributeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.F != nil {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.F))))
		i += 4
	}
	if m.I != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.I))
	}
	if m.S != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(m.S)))
		i += copy(dAtA[i:], m.S)
	}
	if m.T != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.T.Size()))
		n1, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.G != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.G.Size()))
		n2, err := m.G.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Floats) > 0 {
		for _, num := range m.Floats {
			dAtA[i] = 0x3d
			i++
			f3 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
			i += 4
		}
	}
	if len(m.Ints) > 0 {
		for _, num := range m.Ints {
			dAtA[i] = 0x40
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(num))
		}
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Tensors) > 0 {
		for _, msg := range m.Tensors {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Graphs) > 0 {
		for _, msg := range m.Graphs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DocString != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if m.Type != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.Type))
	}
	if m.RefAttrName != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.RefAttrName)))
		i += copy(dAtA[i:], *m.RefAttrName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValueInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Type != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.Type.Size()))
		n4, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DocString != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Name != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.OpType != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.OpType)))
		i += copy(dAtA[i:], *m.OpType)
	}
	if len(m.Attribute) > 0 {
		for _, msg := range m.Attribute {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DocString != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if m.Domain != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IrVersion != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.IrVersion))
	}
	if m.ProducerName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.ProducerName)))
		i += copy(dAtA[i:], *m.ProducerName)
	}
	if m.ProducerVersion != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.ProducerVersion)))
		i += copy(dAtA[i:], *m.ProducerVersion)
	}
	if m.Domain != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if m.ModelVersion != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.ModelVersion))
	}
	if m.DocString != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if m.Graph != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.Graph.Size()))
		n5, err := m.Graph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.OpsetImport) > 0 {
		for _, msg := range m.OpsetImport {
			dAtA[i] = 0x42
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetadataProps) > 0 {
		for _, msg := range m.MetadataProps {
			dAtA[i] = 0x72
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StringStringEntryProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringStringEntryProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GraphProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, msg := range m.Node {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Initializer) > 0 {
		for _, msg := range m.Initializer {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DocString != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if len(m.Input) > 0 {
		for _, msg := range m.Input {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Output) > 0 {
		for _, msg := range m.Output {
			dAtA[i] = 0x62
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ValueInfo) > 0 {
		for _, msg := range m.ValueInfo {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TensorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, num := range m.Dims {
			dAtA[i] = 0x8
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(num))
		}
	}
	if m.DataType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.DataType))
	}
	if m.Segment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.Segment.Size()))
		n6, err := m.Segment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.FloatData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(m.FloatData)*4))
		for _, num := range m.FloatData {
			f7 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f7))
			i += 4
		}
	}
	if len(m.Int32Data) > 0 {
		dAtA9 := make([]byte, len(m.Int32Data)*10)
		var j8 int
		for _, num1 := range m.Int32Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Int64Data) > 0 {
		dAtA11 := make([]byte, len(m.Int64Data)*10)
		var j10 int
		for _, num1 := range m.Int64Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.Name != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.RawData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(m.RawData)))
		i += copy(dAtA[i:], m.RawData)
	}
	if len(m.DoubleData) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(m.DoubleData)*8))
		for _, num := range m.DoubleData {
			f12 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f12))
			i += 8
		}
	}
	if len(m.Uint64Data) > 0 {
		dAtA14 := make([]byte, len(m.Uint64Data)*10)
		var j13 int
		for _, num := range m.Uint64Data {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.DocString != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.DocString)))
		i += copy(dAtA[i:], *m.DocString)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TensorProto_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto_Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.Begin))
	}
	if m.End != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.End))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TensorShapeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShapeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		for _, msg := range m.Dim {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOnnx(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TensorShapeProto_Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShapeProto_Dimension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn15, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.Denotation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Denotation)))
		i += copy(dAtA[i:], *m.Denotation)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TensorShapeProto_Dimension_DimValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintOnnx(dAtA, i, uint64(m.DimValue))
	return i, nil
}
func (m *TensorShapeProto_Dimension_DimParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintOnnx(dAtA, i, uint64(len(m.DimParam)))
	i += copy(dAtA[i:], m.DimParam)
	return i, nil
}
func (m *TypeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn16, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.Denotation != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Denotation)))
		i += copy(dAtA[i:], *m.Denotation)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TypeProto_TensorType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TensorType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.TensorType.Size()))
		n17, err := m.TensorType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *TypeProto_Tensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeProto_Tensor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ElemType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.ElemType))
	}
	if m.Shape != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(m.Shape.Size()))
		n18, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperatorSetIdProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorSetIdProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if m.Version != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx(dAtA, i, uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintOnnx(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AttributeProto) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.F != nil {
		n += 5
	}
	if m.I != nil {
		n += 1 + sovOnnx(uint64(*m.I))
	}
	if m.S != nil {
		l = len(m.S)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.T != nil {
		l = m.T.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.G != nil {
		l = m.G.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.Floats) > 0 {
		n += 5 * len(m.Floats)
	}
	if len(m.Ints) > 0 {
		for _, e := range m.Ints {
			n += 1 + sovOnnx(uint64(e))
		}
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			l = len(b)
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.Tensors) > 0 {
		for _, e := range m.Tensors {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.Graphs) > 0 {
		for _, e := range m.Graphs {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Type != nil {
		n += 2 + sovOnnx(uint64(*m.Type))
	}
	if m.RefAttrName != nil {
		l = len(*m.RefAttrName)
		n += 2 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			l = len(s)
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			l = len(s)
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.OpType != nil {
		l = len(*m.OpType)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.Attribute) > 0 {
		for _, e := range m.Attribute {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModelProto) Size() (n int) {
	var l int
	_ = l
	if m.IrVersion != nil {
		n += 1 + sovOnnx(uint64(*m.IrVersion))
	}
	if m.ProducerName != nil {
		l = len(*m.ProducerName)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.ProducerVersion != nil {
		l = len(*m.ProducerVersion)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.ModelVersion != nil {
		n += 1 + sovOnnx(uint64(*m.ModelVersion))
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.OpsetImport) > 0 {
		for _, e := range m.OpsetImport {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.MetadataProps) > 0 {
		for _, e := range m.MetadataProps {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringStringEntryProto) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GraphProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.Initializer) > 0 {
		for _, e := range m.Initializer {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.Input) > 0 {
		for _, e := range m.Input {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.ValueInfo) > 0 {
		for _, e := range m.ValueInfo {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Dims) > 0 {
		for _, e := range m.Dims {
			n += 1 + sovOnnx(uint64(e))
		}
	}
	if m.DataType != nil {
		n += 1 + sovOnnx(uint64(*m.DataType))
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.FloatData) > 0 {
		n += 1 + sovOnnx(uint64(len(m.FloatData)*4)) + len(m.FloatData)*4
	}
	if len(m.Int32Data) > 0 {
		l = 0
		for _, e := range m.Int32Data {
			l += sovOnnx(uint64(e))
		}
		n += 1 + sovOnnx(uint64(l)) + l
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			l = len(b)
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if len(m.Int64Data) > 0 {
		l = 0
		for _, e := range m.Int64Data {
			l += sovOnnx(uint64(e))
		}
		n += 1 + sovOnnx(uint64(l)) + l
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.RawData != nil {
		l = len(m.RawData)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if len(m.DoubleData) > 0 {
		n += 1 + sovOnnx(uint64(len(m.DoubleData)*8)) + len(m.DoubleData)*8
	}
	if len(m.Uint64Data) > 0 {
		l = 0
		for _, e := range m.Uint64Data {
			l += sovOnnx(uint64(e))
		}
		n += 1 + sovOnnx(uint64(l)) + l
	}
	if m.DocString != nil {
		l = len(*m.DocString)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorProto_Segment) Size() (n int) {
	var l int
	_ = l
	if m.Begin != nil {
		n += 1 + sovOnnx(uint64(*m.Begin))
	}
	if m.End != nil {
		n += 1 + sovOnnx(uint64(*m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorShapeProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Dim) > 0 {
		for _, e := range m.Dim {
			l = e.Size()
			n += 1 + l + sovOnnx(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorShapeProto_Dimension) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.Denotation != nil {
		l = len(*m.Denotation)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TensorShapeProto_Dimension_DimValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOnnx(uint64(m.DimValue))
	return n
}
func (m *TensorShapeProto_Dimension_DimParam) Size() (n int) {
	var l int
	_ = l
	l = len(m.DimParam)
	n += 1 + l + sovOnnx(uint64(l))
	return n
}
func (m *TypeProto) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.Denotation != nil {
		l = len(*m.Denotation)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TypeProto_TensorType) Size() (n int) {
	var l int
	_ = l
	if m.TensorType != nil {
		l = m.TensorType.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	return n
}
func (m *TypeProto_Tensor) Size() (n int) {
	var l int
	_ = l
	if m.ElemType != nil {
		n += 1 + sovOnnx(uint64(*m.ElemType))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperatorSetIdProto) Size() (n int) {
	var l int
	_ = l
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOnnx(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovOnnx(uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOnnx(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOnnx(x uint64) (n int) {
	return sovOnnx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttributeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.F = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.I = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S[:0], dAtA[iNdEx:postIndex]...)
			if m.S == nil {
				m.S = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T == nil {
				m.T = &TensorProto{}
			}
			if err := m.T.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &GraphProto{}
			}
			if err := m.G.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Floats = append(m.Floats, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.Floats) == 0 {
					m.Floats = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Floats = append(m.Floats, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, make([]byte, postIndex-iNdEx))
			copy(m.Strings[len(m.Strings)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tensors = append(m.Tensors, &TensorProto{})
			if err := m.Tensors[len(m.Tensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Graphs = append(m.Graphs, &GraphProto{})
			if err := m.Graphs[len(m.Graphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v AttributeProto_AttributeType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AttributeProto_AttributeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RefAttrName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &TypeProto{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OpType = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attribute = append(m.Attribute, &AttributeProto{})
			if err := m.Attribute[len(m.Attribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrVersion", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrVersion = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProducerName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProducerVersion = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ModelVersion = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &GraphProto{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsetImport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpsetImport = append(m.OpsetImport, &OperatorSetIdProto{})
			if err := m.OpsetImport[len(m.OpsetImport)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataProps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataProps = append(m.MetadataProps, &StringStringEntryProto{})
			if err := m.MetadataProps[len(m.MetadataProps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringStringEntryProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringStringEntryProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringStringEntryProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &NodeProto{})
			if err := m.Node[len(m.Node)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initializer = append(m.Initializer, &TensorProto{})
			if err := m.Initializer[len(m.Initializer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, &ValueInfoProto{})
			if err := m.Input[len(m.Input)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, &ValueInfoProto{})
			if err := m.Output[len(m.Output)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueInfo = append(m.ValueInfo, &ValueInfoProto{})
			if err := m.ValueInfo[len(m.ValueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dims = append(m.Dims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dims = append(m.Dims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var v TensorProto_DataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TensorProto_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataType = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &TensorProto_Segment{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.FloatData = append(m.FloatData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.FloatData) == 0 {
					m.FloatData = make([]float32, 0, packedLen/4)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.FloatData = append(m.FloatData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatData", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int32Data = append(m.Int32Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int32Data = append(m.Int32Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Data", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData, make([]byte, postIndex-iNdEx))
			copy(m.StringData[len(m.StringData)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int64Data = append(m.Int64Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int64Data = append(m.Int64Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Data", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = append(m.RawData[:0], dAtA[iNdEx:postIndex]...)
			if m.RawData == nil {
				m.RawData = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.DoubleData = append(m.DoubleData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				if len(m.DoubleData) == 0 {
					m.DoubleData = make([]float64, 0, packedLen/8)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.DoubleData = append(m.DoubleData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint64Data = append(m.Uint64Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint64Data = append(m.Uint64Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Data", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DocString = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProto_Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Begin = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShapeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShapeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShapeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dim = append(m.Dim, &TensorShapeProto_Dimension{})
			if err := m.Dim[len(m.Dim)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShapeProto_Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &TensorShapeProto_Dimension_DimValue{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &TensorShapeProto_Dimension_DimParam{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Denotation = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeProto_Tensor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &TypeProto_TensorType{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Denotation = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeProto_Tensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemType", wireType)
			}
			var v TensorProto_DataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TensorProto_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ElemType = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorSetIdProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorSetIdProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorSetIdProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOnnx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOnnx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOnnx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOnnx
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOnnx
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOnnx(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOnnx = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOnnx   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("onnx.proto", fileDescriptor_onnx_66ef03ffacf11547) }

var fileDescriptor_onnx_66ef03ffacf11547 = []byte{
	// 1347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0xf7, 0x8a, 0x92, 0x28, 0x0e, 0x25, 0x65, 0xff, 0x8b, 0xc4, 0x7f, 0xc6, 0x68, 0x1c, 0x55,
	0x01, 0x0a, 0x35, 0x0d, 0x0c, 0x5b, 0x36, 0x94, 0x14, 0xbd, 0xd4, 0x8e, 0x95, 0x44, 0x80, 0x23,
	0x19, 0x2b, 0x25, 0xe8, 0x8d, 0x60, 0xcc, 0x95, 0x43, 0xd4, 0xfc, 0x00, 0xb9, 0x4a, 0xea, 0xde,
	0xfa, 0x08, 0xbd, 0xf5, 0x11, 0x7a, 0xef, 0xad, 0x7d, 0x81, 0x1e, 0x7a, 0x68, 0xdf, 0x20, 0x48,
	0x5f, 0xa4, 0xd8, 0x59, 0x52, 0x5f, 0x76, 0x92, 0x8b, 0x30, 0x33, 0xfb, 0x9b, 0x0f, 0xce, 0xfe,
	0x66, 0x47, 0x00, 0x71, 0x14, 0xfd, 0xb0, 0x93, 0xa4, 0xb1, 0x8c, 0x59, 0x59, 0xc9, 0xed, 0x3f,
	0xca, 0xd0, 0x3c, 0x94, 0x32, 0x0d, 0x5e, 0xcd, 0xa4, 0x38, 0xc5, 0x03, 0x06, 0xe5, 0xc8, 0x0b,
	0x85, 0x43, 0x5a, 0xa4, 0x63, 0x71, 0x94, 0x59, 0x1d, 0xc8, 0xd4, 0x29, 0xb5, 0x48, 0xa7, 0xc4,
	0xc9, 0x54, 0x69, 0x81, 0x63, 0xb4, 0x48, 0xc7, 0xe0, 0x24, 0x50, 0x5a, 0xe6, 0x94, 0x5b, 0xa4,
	0x53, 0xe7, 0x24, 0x63, 0x77, 0x81, 0x48, 0xa7, 0xd2, 0x22, 0x1d, 0xbb, 0xfb, 0xbf, 0x1d, 0x4c,
	0x37, 0x11, 0x51, 0x16, 0xa7, 0x18, 0x9b, 0x13, 0xc9, 0xb6, 0x81, 0x9c, 0x3b, 0x55, 0x04, 0x50,
	0x0d, 0x78, 0x9a, 0x7a, 0xc9, 0xeb, 0xfc, 0xfc, 0x9c, 0x6d, 0x42, 0x75, 0x7a, 0x11, 0x7b, 0x32,
	0x73, 0xcc, 0x96, 0xd1, 0x29, 0xf1, 0x5c, 0x53, 0x65, 0x05, 0x91, 0xcc, 0x9c, 0x5a, 0xcb, 0xe8,
	0x18, 0x1c, 0x65, 0xe6, 0x80, 0x99, 0xc9, 0x34, 0x88, 0xce, 0x33, 0xc7, 0x6a, 0x19, 0x9d, 0x3a,
	0x2f, 0x54, 0xf6, 0x15, 0x98, 0x12, 0xf3, 0x66, 0x0e, 0xb4, 0x8c, 0xeb, 0x8b, 0x29, 0x10, 0xac,
	0x03, 0xd5, 0x73, 0x55, 0x43, 0xe6, 0xd8, 0x88, 0xbd, 0x5a, 0x57, 0x7e, 0xce, 0xee, 0x00, 0xf8,
	0xf1, 0x99, 0xab, 0xb3, 0x38, 0x0d, 0xec, 0x90, 0xe5, 0xc7, 0x67, 0x63, 0x34, 0xb0, 0x1e, 0x94,
	0xe5, 0x65, 0x22, 0x9c, 0x9b, 0x2d, 0xd2, 0x69, 0x76, 0xdb, 0x3a, 0xcc, 0x6a, 0x7b, 0x17, 0xea,
	0xe4, 0x32, 0x11, 0x1c, 0xf1, 0xac, 0x0d, 0x8d, 0x54, 0x4c, 0x5d, 0x4f, 0xca, 0xd4, 0xc5, 0xde,
	0xdf, 0xc2, 0xc8, 0x76, 0x2a, 0xa6, 0x0a, 0x3e, 0xf4, 0x42, 0xd1, 0xfe, 0x99, 0x40, 0x63, 0xc5,
	0x97, 0x35, 0xc0, 0x7a, 0x31, 0x3c, 0xee, 0x3f, 0x19, 0x0c, 0xfb, 0xc7, 0x74, 0x83, 0x59, 0x50,
	0x79, 0x72, 0x32, 0x3a, 0x9c, 0x50, 0xc2, 0x4c, 0x30, 0x06, 0xc3, 0x09, 0x2d, 0x31, 0x80, 0xea,
	0x78, 0xc2, 0x07, 0xc3, 0xa7, 0xd4, 0x50, 0xf2, 0xa4, 0x3f, 0x1c, 0x8f, 0x38, 0x2d, 0x2b, 0xec,
	0x53, 0x7e, 0x78, 0xfa, 0x8c, 0x56, 0x94, 0x19, 0xdd, 0xc6, 0xb4, 0xca, 0x6a, 0x50, 0x1e, 0x0c,
	0x27, 0x63, 0x6a, 0x32, 0x1b, 0x4c, 0xed, 0x38, 0xa6, 0x35, 0xa5, 0x68, 0xcf, 0x31, 0xb5, 0x14,
	0x1e, 0x5d, 0xc7, 0x14, 0xda, 0xaf, 0xa1, 0xf9, 0xd2, 0xbb, 0x98, 0x89, 0x41, 0x34, 0x8d, 0x3f,
	0x4c, 0x9e, 0x7b, 0x79, 0x57, 0x4a, 0x78, 0xe9, 0x37, 0xf2, 0x8b, 0xb8, 0x4c, 0x74, 0x43, 0xf2,
	0x16, 0xac, 0x76, 0xd6, 0x58, 0xeb, 0x6c, 0xfb, 0x1f, 0x02, 0xd6, 0x30, 0xf6, 0x73, 0x8a, 0xde,
	0x84, 0x4a, 0x10, 0x25, 0x33, 0xe9, 0x90, 0x96, 0xd1, 0xb1, 0xb8, 0x56, 0x14, 0x73, 0xe2, 0x99,
	0x54, 0xe6, 0x12, 0x9a, 0x73, 0x6d, 0x5e, 0x93, 0xb1, 0x54, 0xd3, 0xff, 0xc1, 0x8c, 0x13, 0x17,
	0xcb, 0x2a, 0xa3, 0xb9, 0x1a, 0x27, 0xd8, 0xd4, 0x2e, 0x58, 0x5e, 0xd1, 0x65, 0xa7, 0x82, 0x74,
	0xb8, 0x79, 0xdd, 0x3d, 0xf2, 0x05, 0x6c, 0xad, 0xf6, 0xea, 0x3a, 0x2b, 0x36, 0xa1, 0xea, 0xc7,
	0xa1, 0x17, 0x44, 0x8e, 0xa9, 0x53, 0x69, 0xad, 0xfd, 0x93, 0x01, 0xf0, 0x3c, 0xf6, 0xc5, 0x85,
	0xfe, 0xa8, 0x3b, 0x00, 0x41, 0xea, 0xbe, 0x11, 0x69, 0x16, 0xc4, 0x11, 0x36, 0xd0, 0xe0, 0x56,
	0x90, 0xbe, 0xd4, 0x06, 0x76, 0x0f, 0x1a, 0x49, 0x1a, 0xfb, 0xb3, 0x33, 0x91, 0x73, 0xa4, 0x84,
	0xc1, 0xea, 0x85, 0x51, 0x91, 0x84, 0x7d, 0x09, 0x74, 0x0e, 0x2a, 0x22, 0xe9, 0xcf, 0xbe, 0x51,
	0xd8, 0x8b, 0x78, 0x8b, 0xaa, 0xca, 0xcb, 0x55, 0xa9, 0x3c, 0xa1, 0x2a, 0x6a, 0xee, 0x5f, 0xc1,
	0x4a, 0xea, 0x68, 0x2c, 0x9c, 0x3f, 0xf1, 0xc5, 0x5f, 0x40, 0x05, 0x07, 0x06, 0x3f, 0xf8, 0xba,
	0x79, 0xd2, 0xc7, 0xec, 0x1b, 0xa8, 0xc7, 0x49, 0x26, 0xa4, 0x1b, 0x84, 0x49, 0x9c, 0x4a, 0x9c,
	0x6d, 0xbb, 0xeb, 0x68, 0xf8, 0x28, 0x11, 0xa9, 0x27, 0xe3, 0x74, 0x2c, 0xe4, 0xc0, 0xd7, 0x6e,
	0x36, 0xa2, 0x07, 0x08, 0x66, 0x8f, 0xa1, 0x19, 0x0a, 0xe9, 0xf9, 0x9e, 0xf4, 0xdc, 0x24, 0x8d,
	0x93, 0xcc, 0x69, 0xa2, 0xfb, 0x67, 0xda, 0x5d, 0x97, 0xa2, 0x7f, 0xfb, 0x91, 0x4c, 0x2f, 0x75,
	0x88, 0x46, 0xe1, 0x73, 0xaa, 0x5c, 0xda, 0xdf, 0xc2, 0xe6, 0xf5, 0x40, 0x46, 0xc1, 0xf8, 0x5e,
	0x5c, 0xe6, 0x44, 0x56, 0xa2, 0x62, 0xdd, 0x1b, 0xc5, 0xf6, 0xbc, 0xf3, 0x5a, 0x69, 0xff, 0x5a,
	0x02, 0x58, 0x7c, 0x99, 0x22, 0x7b, 0x14, 0xfb, 0x02, 0x99, 0x39, 0x27, 0xfb, 0x9c, 0xb9, 0x1c,
	0x0f, 0xe7, 0x8c, 0x2c, 0x2d, 0x31, 0x72, 0x1f, 0xec, 0x20, 0x0a, 0x64, 0xe0, 0x5d, 0x04, 0x3f,
	0x8a, 0x34, 0xa7, 0xde, 0x35, 0xaf, 0xd6, 0x32, 0x6a, 0xed, 0x1e, 0x60, 0xfd, 0x1e, 0xee, 0x17,
	0x73, 0x62, 0x2f, 0x13, 0x79, 0x75, 0x64, 0x8b, 0xe9, 0x79, 0x30, 0x9f, 0x9e, 0xfa, 0x47, 0xc0,
	0xc5, 0x4c, 0xed, 0x03, 0xe0, 0xe7, 0xbb, 0x41, 0x34, 0x8d, 0x9d, 0xc6, 0x47, 0x3c, 0xac, 0x37,
	0x85, 0xde, 0xfe, 0xad, 0x02, 0xf6, 0xd2, 0xa7, 0xa8, 0x36, 0xf8, 0x41, 0x98, 0x61, 0xaf, 0x0c,
	0x8e, 0x32, 0x7b, 0x08, 0x16, 0xde, 0xe8, 0xfc, 0xc5, 0x68, 0x76, 0xb7, 0xae, 0x34, 0x61, 0xe7,
	0xd8, 0x93, 0x1e, 0xbe, 0x9f, 0x35, 0x3f, 0x97, 0xd8, 0x3e, 0x98, 0x99, 0x38, 0x0f, 0x45, 0x24,
	0x91, 0xf1, 0x76, 0xf7, 0xf6, 0x55, 0xb7, 0xb1, 0x06, 0xf0, 0x02, 0xc9, 0x3e, 0x07, 0xc0, 0xf5,
	0xe2, 0xaa, 0x30, 0x4e, 0x59, 0x2d, 0x9c, 0xa3, 0x12, 0x25, 0xdc, 0x42, 0xab, 0xca, 0xa2, 0x20,
	0x41, 0x24, 0xf7, 0xbb, 0x1a, 0xa2, 0xae, 0xa5, 0xa2, 0x21, 0x68, 0x45, 0xc8, 0x5d, 0xb0, 0xf5,
	0x0d, 0x68, 0x4c, 0x15, 0x57, 0x11, 0x68, 0xd3, 0x52, 0x8c, 0xde, 0x81, 0x3e, 0x57, 0x7b, 0xcd,
	0x98, 0xc7, 0xe8, 0x1d, 0x20, 0xa4, 0xa0, 0x44, 0x6d, 0x89, 0x12, 0xb7, 0xa1, 0x96, 0x7a, 0x6f,
	0xb5, 0x93, 0x85, 0x0b, 0xd6, 0x4c, 0xbd, 0xb7, 0x08, 0xbf, 0x07, 0xb6, 0x1f, 0xcf, 0x5e, 0x5d,
	0x08, 0x7d, 0xaa, 0x76, 0x1c, 0xc1, 0x90, 0xa0, 0xcd, 0x05, 0x68, 0xb6, 0x94, 0x57, 0x91, 0xa0,
	0xac, 0x41, 0xb3, 0x45, 0xe2, 0x55, 0x0a, 0xd5, 0xd7, 0x28, 0xb4, 0xb5, 0x07, 0x66, 0xde, 0x35,
	0xc5, 0xff, 0x57, 0xe2, 0x3c, 0x28, 0xde, 0x26, 0xad, 0xa8, 0x39, 0x11, 0x91, 0x8f, 0x57, 0x65,
	0x70, 0x25, 0xb6, 0xff, 0x22, 0x50, 0x2b, 0x2e, 0xe8, 0x23, 0x4b, 0xca, 0x82, 0xca, 0x8b, 0xc1,
	0x70, 0xf2, 0x88, 0x96, 0xf2, 0xbd, 0xf3, 0x48, 0x2f, 0x29, 0x65, 0xdc, 0xeb, 0xe9, 0x25, 0xa5,
	0xc5, 0x4a, 0x2e, 0xee, 0x77, 0x69, 0x35, 0x17, 0x7b, 0x07, 0xd4, 0x5c, 0xda, 0x6e, 0x35, 0x15,
	0xe2, 0x68, 0x34, 0x3a, 0xa1, 0x96, 0xda, 0x56, 0x98, 0x62, 0xaf, 0x47, 0x41, 0x41, 0x8e, 0x47,
	0x2f, 0x8e, 0x4e, 0xfa, 0xd4, 0x2e, 0x62, 0xef, 0x77, 0x69, 0xbd, 0x90, 0x7b, 0x07, 0xb4, 0xa1,
	0x4a, 0x7c, 0x3c, 0x7a, 0x7e, 0x7a, 0xd2, 0xff, 0xae, 0x77, 0x40, 0x9b, 0xac, 0x09, 0x90, 0xab,
	0x7b, 0xdd, 0x47, 0xf4, 0x46, 0xfb, 0x77, 0x02, 0x54, 0x93, 0x68, 0xfc, 0xda, 0xcb, 0x97, 0x16,
	0xeb, 0x82, 0xe1, 0x07, 0x61, 0x3e, 0xe5, 0xad, 0x65, 0xa6, 0x2d, 0x40, 0x3b, 0xc7, 0x41, 0x28,
	0x22, 0xf5, 0x5e, 0x72, 0x05, 0xde, 0x4a, 0xc1, 0x9a, 0x5b, 0xd8, 0x1d, 0xb0, 0xfc, 0x20, 0x74,
	0xf5, 0x83, 0x82, 0x0d, 0x7d, 0xb6, 0xc1, 0x6b, 0x7e, 0x10, 0xe2, 0xf8, 0x14, 0xc7, 0x89, 0x97,
	0x7a, 0xa1, 0x7e, 0x26, 0xf2, 0xe3, 0x53, 0x65, 0x61, 0xdb, 0x00, 0xbe, 0x88, 0x62, 0xe9, 0xc9,
	0xc5, 0x0b, 0xbf, 0x64, 0x39, 0x32, 0xf3, 0xa7, 0xaa, 0xfd, 0x8e, 0x80, 0x35, 0x5f, 0xb5, 0xec,
	0x6b, 0xb0, 0xf5, 0x7f, 0x1e, 0x3d, 0x5e, 0x04, 0xe7, 0x64, 0x73, 0x6d, 0x21, 0xe7, 0xdf, 0xf1,
	0x6c, 0x83, 0x83, 0x06, 0xe3, 0x3d, 0xae, 0x66, 0xac, 0xae, 0x67, 0xdc, 0x8a, 0xa1, 0xaa, 0xfd,
	0xd4, 0x04, 0x8b, 0x0b, 0x11, 0x2e, 0x52, 0x7c, 0x62, 0x82, 0x15, 0x18, 0x53, 0x3c, 0x80, 0x4a,
	0xa6, 0x9a, 0x97, 0xff, 0x51, 0xd8, 0xbc, 0xbe, 0xab, 0x5c, 0x83, 0x16, 0x9f, 0xf8, 0x04, 0xd8,
	0xd5, 0x55, 0xb1, 0xb4, 0xde, 0xc8, 0xca, 0x7a, 0x73, 0xc0, 0x2c, 0x16, 0x9b, 0xa6, 0x6c, 0xa1,
	0xde, 0x3f, 0x03, 0xb3, 0x58, 0x6f, 0x0c, 0x9a, 0xee, 0x78, 0x72, 0xc8, 0x27, 0xee, 0xcb, 0x3e,
	0x1f, 0x0f, 0x46, 0x43, 0xba, 0xc1, 0x6e, 0xc3, 0xad, 0x01, 0x2f, 0x74, 0xb7, 0xbb, 0xbb, 0xf7,
	0xd0, 0xdd, 0xdb, 0x75, 0xf7, 0x76, 0x29, 0xf9, 0xc0, 0xd1, 0xfe, 0x2e, 0x2d, 0x29, 0x32, 0x2d,
	0x8e, 0xa8, 0x71, 0x44, 0xff, 0x7c, 0xbf, 0x4d, 0xfe, 0x7e, 0xbf, 0x4d, 0xde, 0xbd, 0xdf, 0x26,
	0xbf, 0xfc, 0xbb, 0xbd, 0xf1, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x84, 0x53, 0x12, 0x4d, 0x94,
	0x0b, 0x00, 0x00,
}
